import System;
import Vendor.Onux.ConsoleStyle;

external process;

/**
 * js++Unit is an xUnit testing framework for writing and running automated 
 * tests.
 */
module Vendor.JSPPUnit
{
	// TODO: RFCT: refactor to a private 'Utils' module once we have classes to access PADDING globally
	/**
	 * Gets the indentation for pretty printing test output to the console.
	 *
	 * @return The currently-appropriate indentation as a string.
	 */
	private string getPadding() {
		string padding = Utils.PADDING;
		for (int i = 0; i < State.counter_indent; ++i) {
			padding += Utils.PADDING;
		}

		return padding;
	}
	/**
	 * Prints the title for the current test suite.
	 */
	private void printSuiteTitle(string title) {
		Console.log(getPadding() + title);
		Console.log("");
	}

	// TODO: RFCT: refactor to a 'Run' module?
	// TODO: RFCT: refactor runSuite() common logic... only type is different. compiler bug?
	/**
	 * @overload runSuite
	 *
	 * Executes a test suite.
	 */
	/**
	 * @param code The callback defined for the test suite.
	 */
	private void runSuite(void() code) {
		++State.counter_indent;
		code();
		Console.log("");
		--State.counter_indent;
	}
	/**
	 * @param code The callback defined for the test suite.
	 */
	private void runSuite(external code) {
		++State.counter_indent;
		code();
		Console.log("");
		--State.counter_indent;
	}
	/**
	 * @overload runTest
	 *
	 * Executes a test.
	 */
	/**
	 * @param title The title defined for the test.
	 * @param code The callback defined for the test.
	 * @param exceptionPasses Does a thrown exception qualify as a passed test?
	 */
	private void runTest(string title, void() code, bool exceptionPasses) {
		runTest(title, code, exceptionPasses, null);
	}
	/**
	 * @param title The title defined for the test.
	 * @param code The callback defined for the test.
	 * @param exceptionPasses Does a thrown exception qualify as a passed test?
	 * @param exception The exception to expect if a thrown exception qualifies as a passed test.
	 */
	private void runTest(string title, void() code, bool exceptionPasses, external exception) {
		bool caught = false;
		var exceptionObject;
		string PASS = "\u2714", FAIL = "\u2716";

		try {
			code();
		}
		catch(external e) {
			bool requiresException = exception != null;
			bool exceptionMatches = e === exception;

			caught = requiresException ? exceptionMatches : true;
			exceptionObject = e;
		}
		finally {
			if (exceptionPasses ? caught : !caught) {
				Console.log(getPadding() + ConsoleStyle.Colors.green(Utils.PADDING + PASS) + " " + ConsoleStyle.Colors.gray(title));
				++State.counter_passedTests;
			}
			else {
				Console.log(getPadding() + ConsoleStyle.Colors.red(Utils.PADDING + FAIL + " " +  title));

				if (!exceptionPasses) {
					Console.log(getPadding() + Utils.PADDING + ConsoleStyle.Colors.red(exceptionObject));
					++State.counter_failedTests;
				}
			}
		}

		++State.counter_runTests;
	}

	/**
	 * Defines a test suite.
	 *
	 * @param title The title of the test suite.
	 * @param code The code for the test suite.
	 */
	public void suite(string title, void() code) {
		if (State.running) {
			printSuiteTitle(title);
			runSuite(code);
		}
		else {
			State.suitesQueue[title] = code;
		}
	}

	/**
	 * Defines a test.
	 *
	 * @param title The title of the test.
	 * @param code The code for the test.
	 */
	public void test(string title, void() code) {
		runTest(title, code, false);
	}

	/**
	 * Defines a skipped test.
	 *
	 * @param title The title of the test.
	 * @param code The code for the test.
	 */
	public void skip(string title, void() code) {
		string SKIP = "\u25CB";
		Console.log(getPadding() + ConsoleStyle.Colors.cyan(Utils.PADDING + SKIP + " " + title));
		++State.counter_skippedTests;
	}

	/**
	 * Defines a test that expects an exception to be thrown.
	 *
	 * @param title The title of the test.
	 * @param code The code for the test.
	 */
	public void throws(string title, void() code) {
		runTest(title, code, true);
	}
	/**
	 * Defines a test that expects a specific exception to be thrown.
	 *
	 * @param title The title of the test.
	 * @param code The code for the test.
	 * @param exception The type of exception to expect.
	 */
	public void throws(string title, void() code, external exception) {
		runTest(title, code, true, exception);
	}


	/**
	 * Runs the defined tests.
	 */
	public void run() {
		State.running = true;
		Console.log("");

		// TODO: replace with 'System.Benchmark'
		Date d = new Date();
		double t = d.getTime();

		for(string suiteTitle in State.suitesQueue) {
			printSuiteTitle(suiteTitle);

			void() suiteCode = State.suitesQueue[suiteTitle];
			runSuite(suiteCode);
		}

		string output = "";
		Console.log(String.EMPTY);
		if (State.counter_passedTests > 0)  {
			double time = (new Date).getTime() - t;

			output += Utils.PADDING;
			output += ConsoleStyle.Colors.green(
				State.counter_passedTests.toString() + " passing"
			);
			output += ConsoleStyle.Colors.gray(" (" + time.toString() + "ms)");
		}
		if (State.counter_skippedTests > 0) {
			output += Utils.PADDING;
			output += ConsoleStyle.Colors.cyan(
				State.counter_skippedTests.toString() + " skipped"
			);
		}
		if (State.counter_failedTests > 0) {
			output += Utils.PADDING;
			output += ConsoleStyle.Colors.red(
				State.counter_failedTests.toString() + " failed"
			);
		}
		Console.log(output);
		Console.log(String.EMPTY);

		if (State.counter_failedTests > 0 && typeof process == "object") {
			process.exit(1);
		}
	}
}